---
title: "Pay to Win: A Data-Driven Exploration of Gaming Industry Profits"
format: pdf
editor: visual
---

```{r}

# Place your initializer chunks here.

# Travis
install.packages("caret")
library(tidyverse)
library(tidymodels)
library(dplyr)
library(readr)
library(tibble)
library(stringr)
library(caret)
Games_Tidy <- read_csv("https://raw.githubusercontent.com/Jtsilva26/GameDataAnalysis/main/Games.csv", show_col_types=FALSE)
Dev_Tidy <- read_csv("https://raw.githubusercontent.com/Jtsilva26/GameDataAnalysis/main/Developer.csv", show_col_types=FALSE)
steam <- read_csv("https://raw.githubusercontent.com/Jtsilva26/GameDataAnalysis/main/steam.csv", col_types = cols(my_date = col_date(format = "%Y-%m-%d")))


```

# TO MAKE IT WORK (REMOVE FOR FINAL PRODUCT OR OTHERS WORK)

```{r}
# Function to convert abbreviated revenue to numerical values
convert_revenue <- function(revenue) {
  # If the revenue contains 'm' (million), remove 'm' and multiply by 1,000,000
  if (grepl("m", revenue, fixed = TRUE)) {
    revenue <- as.numeric(gsub("[^0-9.]", "", revenue)) * 1000000
  }
  # If the revenue contains 'b' (billion), remove 'b' and multiply by 1,000,000,000
  else if (grepl("b", revenue, fixed = TRUE)) {
    revenue <- as.numeric(gsub("[^0-9.]", "", revenue)) * 1000000000
  }
  # If the revenue contains 'k' (thousand), remove 'k' and multiply by 1,000
  else if (grepl("k", revenue, fixed = TRUE)) {
    revenue <- as.numeric(gsub("[^0-9.]", "", revenue)) * 1000
  } else {
    revenue <- as.numeric(gsub("[^0-9.]", "", revenue))
  }
  return(revenue)
}
```

```{r}
split_genres_games <- function(genre_string_games) {
  genre_list_games <- unlist(strsplit(genre_string_games, ", "))
  return(genre_list_games)
}

split_genres_steam <- function(genre_string_steam) {
  genre_list_steam <- unlist(strsplit(genre_string_steam, ";"))
  return(genre_list_steam)
}
```

```{r}
DS_GetAllOf <- function(data, col_name, search_val) {
  desired_rows <- which(sapply(data[[col_name]], function(x) search_val %in% x[[1]]))
  return(data[desired_rows,])
}
```

```{r}
# Apply the function to the 'reviews' column in the 'Games' data frame
Games_Tidy$Reviews <- sapply(Games_Tidy$Reviews, convert_revenue)
Games_Tidy$`Est. Units Sold` <- sapply(Games_Tidy$`Est. Units Sold`, convert_revenue)
Games_Tidy$Followers <- sapply(Games_Tidy$Followers, convert_revenue)
Games_Tidy$`Est. Revenue` <- sapply(Games_Tidy$`Est. Revenue`, convert_revenue)

# Remove the 'review_numeric' column if you no longer need it
Games_Tidy$review_numeric <- NULL
Games_Tidy$follower_numeric <- NULL
Games_Tidy$units_sold <- NULL
Games_Tidy$revenue <- NULL

# Apply the function to create a list of genres
Games_Tidy$Genres <- lapply(Games_Tidy$Genres, split_genres_games)

Games_Tidy$Developers <- lapply(Games_Tidy$Developers, split_genres_games)

Games_Tidy$Publishers <- lapply(Games_Tidy$Publishers, split_genres_games)

Games_Tidy$`Publisher Class` <- lapply(Games_Tidy$`Publisher Class`, split_genres_games)

# Rearrange the date values in the dataset
Games_Tidy$`First Released` <- as.Date(Games_Tidy$`First Released`, format = "%b %d, %Y")

# Converts all FREE values in price to 0.00
Games_Tidy$Price[Games_Tidy$Price == "Free"] <- "$0.00"

# Removes dollar sign and converts them to doubles
Games_Tidy$Price <- as.numeric(gsub("\\$", "", Games_Tidy$Price))

# Now, the 'Reviews' column contains the converted values
print(Games_Tidy)
```

```{r}
Dev_Tidy$`Total revenue` <- sapply(Dev_Tidy$`Total revenue`, convert_revenue)
Dev_Tidy$`Avg revenue per game` <- sapply(Dev_Tidy$`Avg revenue per game`, convert_revenue)

print(Dev_Tidy)
```

```{r}
# Apply the function to create a list of genres
steam$genres <- sapply(steam$genres,split_genres_steam)

steam$steamspy_tags <- sapply(steam$steamspy_tags,split_genres_steam)

steam$categories <- sapply(steam$categories, split_genres_steam)

steam$platforms <- sapply(steam$platforms, split_genres_steam)

steam$developer <- sapply(steam$developer, split_genres_steam)

steam$publisher <- sapply(steam$publisher, split_genres_steam)

# Access the third element (Multiplayer) in the split data
desired_element <- steam$genres

print(steam)
```

```{r}
print(steam[indie_rows,])
print(steam$genres[20][[1]])
indierows <- DS_GetAllOf(steam, "release_date", "2001-06-01")
indierows
```

# END OF CODE NEEDED TO MAKE IT WORK

# Introduction

## Question

///// stuff

## Related work

// VGInsights output

// sights we we got the data from

// related analytics

// most companies do something like this in their annuals

# Methods

## Process: Data Search and Collection

### Searching for data

+// how we did it

-   Travis: Google searching mostly

+// Problems?

-   Travis: A lot of the better data was behind a pay wall and a few sources that had good data on github required an "ok" before using their data and they turned us down.

### Obtaining Data: Web Scraping

+// how we did it

+// why so jank

+// Problems?

-   Travis: The better sources were hard to web-scrape due to the site being loaded dynamically on clicking the table. We ran into issues using RSelenium and the web drivers for the different browsers not being accessible and making it just about impossible to web-scrape easily. This ended up being the start of our problems that led to us having the data we ended up with. Below is a snippet of some of the code we used to scrape of our initial data sources.

```         
driver <- rsDriver(browser = "chrome")
remote_driver <- driver$client
remote_driver$navigate("https://vginsights.com/games-database")
remote_driver$findElement(using = "css selector", value = "span > button")->element
element$clickElement()

## find button to click to load content
game.data <- read_html("https://vginsights.com/games-database") %>%
  html_element(".mat-typography") %>%
  html_element("app-root")

game.data
```

### Obtaining data: Attempting to reach out to steam charts

### Obtaining data: Kaggle

## Cleaning Data

+// Making all the data uniform as can be

+// Handling Multiple sources of truth

+// inner joins to expand data

-   Travis: Joining the data was a problem because I needed data from each table to do the linear regression. However, upon doing the join it severely limited the number of entries in the table down to 140.

+// Cleaning dates and prices and modifying data (all the stuff we did in qmd tidy)

-   Travis: Alex and I altered Steam Rating column to no longer be a char and be a double in decimal form (was percentage) to be used in the linear regression. I also pruned the rows that had 0's in the Est.Revenue as they were severely hindering our model. If we were trying to predict the factors that influenced the Est. Revenue to be the highest then a value of 0 would skew and ruin the model.

+// Problems?

-   Travis: After doing the inner join and the cleaning of the data that I needed I was left with 105 rows in my table.... A fraction of the data we originally started with but that was all I could get without fabricating values for roughly 150 rows.

## Process: Data Exploration

// Data exploration

+// How did we do it (dont talk about results yet, more technical, QMD and such)

+// What did we do, creating custom functions and stuff for filters,

-   Travis: Created a function to explore different models and their success with different split

+// What did we do specifically because our data was the way it was (see above)

+// Problems?

-   Travis: general lack of data

// Graphs and insights

+// What graphs did we use?

+// Why? What about our data was useful for these graphs

+// What were we hoping to obtain by using these graph types.

+// Problems?

// Linear models

+// What did we do with linear models?

-   NOTE: why did we start/settle on these variables

-   Travis: The goal of this model was to be able to help us predict which game might make the most Revenue

-   Travis: Used a method from stats where we use the lm() function with all of our variables and one by one run it and remove the one with the highest p val until the r\^2 starts to decrease. meaning that the variables that are left best impact the dependant variable.

    ```         
    example -> lm(`Est. Revenue` ~ Price + Reviews + steam_ratings + positive_ratings + negative_rating, data = my_data)
    summary(example)
    ```

    say for instance negative_ratings had the highest p-val I would remove it and check the resulting summary to see if the r\^2 increases or decreases. If it didn't decrease I'd repreat the process by removing the next highest p-value and repeat.

-   Travis: This process left me with the "og_formula" model that ends up producing the "best" results. These variables also intuitively made sense as to why they might impact the Estimated Revenue of a game.

```         
og_formula <-`Est. Revenue` ~ Price : `Est. Units Sold` + steam_rating + Reviews + positive_ratings + negative_ratings
```

+// What worked? what didnt? no results yet, just technical

-   Travis: the model that performed the best was one that I called og_formula however it initially was being run with a split of 70-30 and was giving off a mediocre r\^2 value, and high RMSE/MAE numbers. In an attempt to get a better idea of which models might perform the best I created a function that would take in a vector of model formulae and a split. This function was ran with both complex formulae (og_formula) and simple formula (`Est. Revenue` \~ Price) and various splits. After doing this we narrowed down that the og_formula did indeed perform the best out of all other other combinations. Below is the function used and lists of formulae tried.

### Different Formulae

```         
og_formula <-`Est. Revenue` ~ Price : `Est. Units Sold` + steam_rating + Reviews + positive_ratings + negative_ratings

price_formula <-`Est. Revenue` ~ Price

units_sold_formula <-`Est. Revenue` ~`Est. Units Sold` 

steam_rating_formula <-`Est. Revenue` ~ steam_rating

Reviews_formula <-`Est. Revenue` ~ Reviews

Positive_ratings_formula <-`Est. Revenue` ~ positive_ratings

Negative_ratings_formula <-`Est. Revenue` ~ negative_ratings

test_formula <-`Est. Revenue` ~ Price + `Est. Units Sold` + steam_rating + Reviews + positive_ratings - negative_ratings

# Grouping all formula into 
formulae <- c(og_formula, price_formula, units_sold_formula, steam_rating_formula, Reviews_formula, Positive_ratings_formula, Negative_ratings_formula, test_formula)
```

# Function used for training and validation

### v - vector of all formula to run models on

### s - split (fraction from 0-1 representing the portortion of the test data our of our whole data set)

```         
run_models <- function(v, s){
  
  # making sure our split is valid
  if (s >= 1 || s <= 0) s = 0.8
  
  # Splitting data 
  set.seed(385)  # for reproducibility
  split_index <- createDataPartition(games_lm$`Est. Revenue`, p = s, list = FALSE)
  train_data <- games_lm[split_index, ]
  
  #split into training and validation, at the end after settling on the model(s) apply them to the test data
  
  test_data <- games_lm[-split_index, ]
  
  cat("\n\n--------------------------------------------------\n")
  cat("Using split: ", s, "\n")
  cat("--------------------------------------------------\n")
  
  for(i in v) {
    # Define the model
    model <- train(i, data = train_data,method = "lm")
    
    # Make predictions on the testing set
    predictions <- predict(model, newdata = test_data)
    
    # Evaluate model performance
    rmse <- sqrt(mean((test_data$`Est. Revenue` - predictions)^2))
    mae <- mean(abs(test_data$`Est. Revenue` - predictions))
    
    # Compute R-squared
    ss_residual <- sum((test_data$`Est. Revenue` - predictions)^2)
    ss_total <- sum((test_data$`Est. Revenue` - mean(test_data$`Est. Revenue`))^2)
    rsquared <- 1 - (ss_residual / ss_total)

    cat("\nFormula used: ")
    print(i)
    cat("Root Mean Squared Error (RMSE): ", rmse, "\n")
    cat("Mean Absolute Error (MAE): ", mae, "\n")
    cat("R-squared: ", rsquared, "\n")
    cat("--------------------------------------------------\n")
  }
}
```

## Running the function created above for Linear Regression

```         
run_models(formulae, 0.9)
run_models(formulae, 0.8)
run_models(formulae, 0.7)
run_models(formulae, 0.6)
run_models(formulae, 0.5)
```

+// Why did we do what we did with the linear models

+// Problems?

-   major lack of data mostly

## Inner Join Code

```{r}
# Joining tables 
games_joined_inner = inner_join(Games_Tidy, steam, join_by(Name == name))
# Grabbing columns relevant to regression and removing Est. Revenue Outliers
# Altering the steam rating column to be dbl to be used in linear regression
games_lm <- games_joined_inner %>% 
  mutate(steam_rating = as.numeric(gsub("%", "", c(`Steam Rating`))) / 100)
games_lm <- games_lm %>% 
  select(Name, Price,`Est. Revenue`, `Est. Units Sold`,Reviews ,steam_rating, Genres, Publishers, positive_ratings, negative_ratings, average_playtime, median_playtime)
games_lm <- games_lm %>% 
  filter(`Est. Revenue` > 0)

# Defining model formulae
og_formula <-`Est. Revenue` ~ Price : `Est. Units Sold` + steam_rating + Reviews + positive_ratings + negative_ratings

price_formula <-`Est. Revenue` ~ Price

units_sold_formula <-`Est. Revenue` ~`Est. Units Sold` 

steam_rating_formula <-`Est. Revenue` ~ steam_rating

Reviews_formula <-`Est. Revenue` ~ Reviews

Positive_ratings_formula <-`Est. Revenue` ~ positive_ratings

Negative_ratings_formula <-`Est. Revenue` ~ negative_ratings

test_formula <-`Est. Revenue` ~ Price + `Est. Units Sold` + steam_rating + Reviews + positive_ratings - negative_ratings

# Grouping all formula into 
formulae <- c(og_formula, price_formula, units_sold_formula, steam_rating_formula, Reviews_formula, Positive_ratings_formula, Negative_ratings_formula, test_formula)

### Training and testing data
# v - vector of all formula to run models on
# s - split (fraction from 0-1 representing the portortion of the test data our of our whole data set)
run_models <- function(v, s){
  
  # making sure our split is valid
  if (s >= 1 || s <= 0) s = 0.8
  
  # Splitting data 
  set.seed(385)  # for reproducibility
  split_index <- createDataPartition(games_lm$`Est. Revenue`, p = s, list = FALSE)
  train_data <- games_lm[split_index, ]
  
  #split into training and validation, at the end after settling on the model(s) apply them to the test data
  
  test_data <- games_lm[-split_index, ]
  
  cat("\n\n--------------------------------------------------\n")
  cat("Using split: ", s, "\n")
  cat("--------------------------------------------------\n")
  
  for(i in v) {
    # Define the model
    model <- train(i, data = train_data,method = "lm")
    
    # Make predictions on the testing set
    predictions <- predict(model, newdata = test_data)
    
    # Evaluate model performance
    rmse <- sqrt(mean((test_data$`Est. Revenue` - predictions)^2))
    mae <- mean(abs(test_data$`Est. Revenue` - predictions))
    
    # Compute R-squared
    ss_residual <- sum((test_data$`Est. Revenue` - predictions)^2)
    ss_total <- sum((test_data$`Est. Revenue` - mean(test_data$`Est. Revenue`))^2)
    rsquared <- 1 - (ss_residual / ss_total)

    cat("\nFormula used: ")
    print(i)
    cat("Root Mean Squared Error (RMSE): ", rmse, "\n")
    cat("Mean Absolute Error (MAE): ", mae, "\n")
    cat("R-squared: ", rsquared, "\n")
    cat("--------------------------------------------------\n")
  }
}

## Running the function created above for Linear Regression
#run_models(formulae, 0.9)
#run_models(formulae, 0.8)
#run_models(formulae, 0.7)
run_models(formulae, 0.6)
#run_models(formulae, 0.5)
```

# Results

## Process: Answer

+// What was our question again?

+// What games make most money

+// What games have the most players

+// What games have the most competition

+// How did we end up defining things

+// Issues with blowout hits (MAYBE PUT THIS IN THE SECTIONS BEFORE IE: HANDLING MASSIVE OUTLIERS)

## Future Work

## Conclusion

### Contributions

Travis: Linear Model, EDA, Data cleaning
